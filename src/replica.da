from src.object import Object
from enum import Enum
import nacl.signing
import nacl.encoding
import nacl.hash
import nacl.exceptions
import ast

class Modes(Enum):
    ACTIVE = 0
    PENDING = 1
    IMMUTABLE = 2


class Replica(process):

    def setup(replica_id:str, position:int, crypto_keys:tuple, clients):
        self.all_replicas_public_keys = {}
        self.state_object = Object()
        self.history = []
        self.mode = Modes.PENDING
        self.slot = 0
        self.configuration = []
        self.position = position
        self.result_cache = {}
        self.replica_id = replica_id

    def sign(data):
        return crypto_keys[0].sign(str(data).encode())

    def verify(data, replica_id):
        v_key = nacl.signing.VerifyKey(self.all_replicas_public_keys[replica_id],
                                       encoder=nacl.encoding.HexEncoder)
        try:
            v_key.verify(data.message,data.signature)
        except nacl.exceptions.BadSignatureError:
            return False

        output('signature verified')
        return True

    def crypto_hash(data):
        return nacl.hash.sha256(data.encode(), encoder=nacl.encoding.HexEncoder)

    def print_state_object():
        for key in self.state_object.state:
            print(key, '->', self.state_object.state[key])

    def receive(msg= ('all_replicas_public_keys', all_replicas_public_keys)):
        self.all_replicas_public_keys = all_replicas_public_keys
        output("replica: receive all_replicas_public_keys finished")

    def receive(msg=('inithist', history)):
        output('receive handler for inithist')
        self.history = history
        self.mode = Modes.ACTIVE

    def receive(msg=('config', config)):
        output('receiving config from olympus')
        self.configuration = config

    def lower_numbered_slots_present(slot):
        i = 1
        for op in self.history:
            if op[0] != i:
                return False
            i+=1
        return True

    def receive(msg=('request', request_id, request, retransmitted)):
        output("received request with id ", request_id)
        self.slot += 1
        if not lower_numbered_slots_present(slot):
            # holes in history present
            output('slots missing in history..')
            # TODO: send reconfig-request

        # TODO - add conditions like mode is active and all lower numbered slots etc
        output('head sending replica id as ', self.replica_id)
        if len(self.history) < self.slot:
            order_statement = ('order', self.slot, request, self.replica_id)
            signed_order_statement = sign(order_statement) # sign order statement
        # else:
        #    return error
        result = self.state_object.evaluate_request(request)
        output('result of request ', request, ' is ', result)
        output('state object at this moment is ')
        print_state_object()
        order_proof = (self.slot, request_id, request, self, self.configuration,
                       [signed_order_statement])
        output('order proof is ', order_proof)
        self.history.append(order_proof)
        # TODO - hash of result and sign the proof
        signed_result_proof = [sign(('result', request_id, request, crypto_hash(result)))]
        output('result proof is ', signed_result_proof)

        shuttle = (order_proof, signed_result_proof)
        output('sending shuttle to ', self.configuration[self.position + 1])
        send(('shuttle', shuttle), to=self.configuration[self.position + 1])
        # output(verify(b'132123132112322', replica_id))  # REMOVE ME VERIFY_EXAMPLE
        #output('EXAMPLE!!!!!!!', verify(sign(request), self.replica_id))  # REMOVE ME VERIFY_EXAMPLE
        # output(crypto_hash(request))  # REMOVE ME HASH_EXAMPLE
        send('done', to=self) # REMOVE ME

    def receive(msg=('shuttle', shuttle), from_=predeccessor):
        # TODO - do the replicas compare result with predeccessor
        # TODO - check validity
        output('received shuttle from ', predeccessor)
        if not is_order_proof_valid(shuttle[0]):
            output('order proof invalid...')
            # TODO: send reconfig-request

        if not lower_numbered_slots_present(slot):
            # holes in history present
            output('slots missing in history..')
            # TODO: send reconfig-request
        self.slot = shuttle[0][0] # get slot from shuttle
        request_id = shuttle[0][1]
        request = shuttle[0][2]
        order_statement = ('order', self.slot, request, self.replica_id)
        signed_order_statement = sign(order_statement) # sign order statement
        result = self.state_object.evaluate_request(request)
        output('result of request ', request, ' is ', result)
        output('state object at this moment is ')
        print_state_object()

        shuttle[0][5].append(signed_order_statement)

        result_statement = ('result', request_id, request, crypto_hash(result))
        shuttle[1].append(result_statement)
        self.history.append(shuttle[0]) # appending order proof to history

        if self.position != len(self.configuration)-1:   # it is not tail replica
            #output('sending shuttle to ', self.configuration[self.position+1])
            send(('shuttle', shuttle), to=self.configuration[self.position+1])
        else:
            output('tail will send result to client...')
            client = clients[request_id.split('_')[0]]
            send(('result', result, shuttle[1]), to=client)
            # TODO - is the full shuttle cached or just result proof
            self.result_cache[request_id] = (result, shuttle[1])
            if self.position != 0:
                send(('result_shuttle', result, shuttle), to=self.configuration[self.position-1])

    def receive(msg= ('result_shuttle', result, shuttle), from_=successor):
        # TODO - should replica recalculate the result instead of taking tail's result
        # TODO - is the full shuttle cached or just result proof
        request_id = shuttle[0][1]
        self.result_cache[request_id] = (result, shuttle[1])
        if self.position != 0:
            send(('result_shuttle', result, shuttle), to=self.configuration[self.position - 1])
        output('received result shuttle from ', successor)

    def run():
        await(received(('done')))
        await(received('request',))
        output("replica: run finished")

    def is_order_proof_valid(order_proof):
        # order_proof - (self.slot, request_id, request, self, self.configuration,
        #                   [signed_order_statement])
        request = order_proof[2]
        # verify order proof for preceding replicas
        for ord_stmnt in order_proof[5]:
            # get replica id from order_statement
            decoded_message = ast.literal_eval(ord_stmnt.message.decode())
            rplca_id = decoded_message[3]
            request_from_order_statement = decoded_message[2]
            if not verify(ord_stmnt, rplca_id) and request_from_order_statement != request:
                return False
        return True

def main():
    replica = new(Replica, ['adsa', ''], num=1)
    start(replica)
    send(('request', 'id1', 'put(\'fruit\',\'apple\')', 0), to=replica)