
from src.object import Object
from enum import Enum
import nacl.signing
import logging
import nacl.encoding
import nacl.hash
import nacl.exceptions
import ast
import sys
import pickle
import json
import os
import time

INJECTED = "injected"
PENDING = "pending"


class FailureScenarios(Enum):
    CLIENT_REQUEST = "client_request"
    FORWARDED_REQUEST = "forwarded_request"
    SHUTTLE = "shuttle"
    RESULT_SHUTTLE = "result_shuttle"
    CHECKPOINT = "checkpoint"
    COMPLETED_CHECKPOINT = "completed_checkpoint"
    WEDGE_REQUEST = "wedge_request"
    NEW_CONFIGURATION = "new_configuration"
    GET_RUNNING_STATE = "get_running_state"
    CATCH_UP = "catch_up"

class Modes(Enum):
    ACTIVE = 0
    PENDING = 1
    IMMUTABLE = 2


class Replica(process):

    def setup(replica_id:str, position:int, crypto_keys:tuple,
              clients, failure_scenarios, timeout, checkpt_interval, olympus_pub_key, obj=None):

        self.all_replicas_public_keys = {}
        self.all_clients_public_keys = {}
        if obj is None:
            self.state_object = Object()
        else:
            self.state_object = obj
        self.history = []
        self.olympus = None
        self.mode = Modes.PENDING
        self.slot = 0
        self.configuration = []
        self.configuration_number = -1
        self.position = position
        self.result_cache = {}
        self.replica_id = replica_id
        self.olympus_pub_key = olympus_pub_key
        self.last_checkpoint_proof = None
        self.checkpointed_slot = 0
        self.client_requests_tracker = [{
            FailureScenarios.CLIENT_REQUEST: -1,
            FailureScenarios.FORWARDED_REQUEST: -1,
            FailureScenarios.SHUTTLE: -1,
            FailureScenarios.RESULT_SHUTTLE: -1,
        } for _ in range(len(clients))]
        self.message_tracker = {
            FailureScenarios.CHECKPOINT: -1,
            FailureScenarios.COMPLETED_CHECKPOINT: -1,
            FailureScenarios.WEDGE_REQUEST: -1,
            FailureScenarios.NEW_CONFIGURATION: -2,
            FailureScenarios.GET_RUNNING_STATE: -1,
            FailureScenarios.CATCH_UP: -1
        }
        self.failures = {
            INJECTED: {},
            PENDING: {}
        }
        self.TIMER_DURATION = timeout
        self.last_evaluated_result = {}
        self.last_evaluated_request_id = {}
        output('failure scen are', failure_scenarios, level=logging.INFO)
        output('replica setup completed', level=logging.DEBUG)

    def sign(data):
        return crypto_keys[0].sign(str(data).encode())

    # sign verification of other replicas, clients and olympus messages
    def verify(data, id=None, type="replica"):
        if type == "replica":
            v_key = nacl.signing.VerifyKey(self.all_replicas_public_keys[id],
                                   encoder=nacl.encoding.HexEncoder)
        elif type == 'client':
            v_key = nacl.signing.VerifyKey(self.all_clients_public_keys[id],
                                   encoder=nacl.encoding.HexEncoder)
        else:
            v_key = nacl.signing.VerifyKey(self.olympus_pub_key,
                                           encoder=nacl.encoding.HexEncoder)
        try:
            v_key.verify(data.message,data.signature)
        except nacl.exceptions.BadSignatureError:
            return False

        output('signature of', type, 'verified', level= logging.DEBUG)
        return True

    def crypto_hash(data):
        return nacl.hash.sha256(data.encode(), encoder=nacl.encoding.HexEncoder)

    def print_state_object():
        for key in self.state_object.state:
            output(key, '->', self.state_object.state[key], level=logging.INFO)

    def receive(msg=('olympus', olympus)):
        self.olympus = olympus
        output('olympus received', self.olympus, level=logging.DEBUG)

    def receive(msg=('all_clients_public_keys', all_clients_public_keys)):
        self.all_clients_public_keys = all_clients_public_keys
        output('received clients public keys', level=logging.DEBUG)

    def receive(msg=('all_replicas_public_keys', all_replicas_public_keys)):
        decoded_req = ast.literal_eval(all_replicas_public_keys.message.decode())
        if not verify(all_replicas_public_keys, type="olympus"):
            output('signature verification failed for '
                   'all_replicas_public_keys from olympus', level=logging.ERROR)
            return
        self.all_replicas_public_keys = decoded_req
        output("signature verification successful for all_replicas_public_keys from olympus",
               level=logging.INFO)

    def receive(msg=('inithist', history), from_=olympus):
        decoded_req = ast.literal_eval(history.message.decode())
        if not verify(history, type="olympus"):
            output('signature verification failed for inithist from olympus', level= logging.ERROR)
            return

        self.history = decoded_req
        self.mode = Modes.ACTIVE
        self.olympus = olympus
        output('signature verification successful for inithist from olympus', level=logging.INFO)

    def receive(msg=('wedge_request'), from_=sender):
        self.message_tracker[FailureScenarios.WEDGE_REQUEST] += 1
        output('received wedge request from olympus', level=logging.INFO)
        action, trigger, scenario = check_failure_scenario()
        if action:
            if 'crash' in action:
                inject_crash(action, trigger, scenario)
            elif 'sleep' in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                time.sleep(float(action.strip('sleep()'))/1000.0)
            elif 'drop' in action and 'drop_checkpt_stmts' not in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                return
            elif 'extra_op' in action:
                inject_extra_op(action, trigger, scenario)
            elif 'drop_checkpt_stmts' in action:
                self.failures[PENDING].setdefault(self.configuration_number, []).append(scenario)
            elif 'change_operation' in action:
                output('Failure scenario', scenario,'encountered. It wont have any effect', level=logging.INFO)

        self.mode = Modes.IMMUTABLE

        pending = False
        for failure in self.failures[PENDING].get(self.configuration_number, []):
            if 'truncate_history' in failure:
                scenario = failure
                pending = True
                break

        if (action and 'truncate_history' in action) or pending:
            output('!!! taking on pending', level=logging.INFO)
            pending_to_injected(scenario)
            n = int(scenario[scenario.find('truncate_history')+17])
            output('!!! taking on pending n is', n, level=logging.INFO)
            pickled_wedged_stmnt = pickle.dumps(
                (self.replica_id, self.history[:-n], self.last_checkpoint_proof, self.checkpointed_slot))
            send(('wedge_statement', sign(pickled_wedged_stmnt)), to=self.olympus)
        else:
            output('!!! taking on usual', level=logging.INFO)
            pickled_wedged_stmnt = pickle.dumps((self.replica_id, self.history, self.last_checkpoint_proof, self.checkpointed_slot))
            send(('wedge_statement', sign(pickled_wedged_stmnt)), to=self.olympus)

    def receive(msg=('catch_up', hist_suffix), from_=sender):
        self.message_tracker[FailureScenarios.CATCH_UP] += 1
        output('received catch up message from olympus', level=logging.INFO)
        action, trigger, scenario = check_failure_scenario()
        if action:
            if 'crash' in action:
                inject_crash(action, trigger, scenario)
            elif 'sleep' in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                time.sleep(float(action.strip('sleep()')) / 1000.0)
            elif 'drop' in action and 'drop_checkpt_stmts' not in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                return
            elif 'extra_op' in action:
                inject_extra_op(action, trigger, scenario)
            elif 'drop_checkpt_stmts' in action:
                self.failures[PENDING].setdefault(self.configuration_number, []).append(scenario)
            elif 'change_operation' in action:
                output('Failure scenario', scenario,'encountered. It wont have any effect', level=logging.INFO)

        for order_statement in hist_suffix:
            request = order_statement[2]
            output('applying request:', request, level=logging.INFO)
            request_id = order_statement[1]
            result = eval_request(request_id, request)
        output(self.replica_id, 'dictionary-',self.state_object.state)
        send(('caught_up', sign((self.replica_id, crypto_hash(self.state_object), self.last_evaluated_result,
                                 self.last_evaluated_request_id))), to=self.olympus)

    def receive(msg=('terminate'), from_=sender):
        output('received terminate message from olympus', level=logging.INFO)
        sys.exit()

    def receive(msg=('get_running_state'), from_=sender):
        self.message_tracker[FailureScenarios.GET_RUNNING_STATE] += 1
        output('received get running state message from olympus', level=logging.INFO)
        action, trigger, scenario = check_failure_scenario()
        if action:
            if 'crash' in action:
                inject_crash(action, trigger, scenario)
            elif 'sleep' in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                time.sleep(float(action.strip('sleep()')) / 1000.0)
            elif 'drop' in action and 'drop_checkpt_stmts' not in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                return
            elif 'extra_op' in action:
                inject_extra_op(action, trigger, scenario)
            elif 'drop_checkpt_stmts' in action:
                self.failures[PENDING].setdefault(self.configuration_number, []).append(scenario)
            elif 'change_operation' in action:
                output('Failure scenario', scenario,'encountered. It wont have any effect', level=logging.INFO)

        pickled_state = pickle.dumps((self.replica_id, self.state_object))
        send(('running_state', sign(pickled_state)), to=self.olympus)

    def receive(msg=('config', config, config_no)):
        self.message_tracker[FailureScenarios.NEW_CONFIGURATION] += 1
        action, trigger, scenario = check_failure_scenario()
        if action:
            if 'crash' in action:
                inject_crash(action, trigger, scenario)
            elif 'sleep' in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                time.sleep(float(action.strip('sleep()')) / 1000.0)
            elif 'drop' in action and 'drop_checkpt_stmts' not in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                return
            elif 'extra_op' in action:
                inject_extra_op(action, trigger, scenario)
            elif 'increment_slot' in action:
                inject_increment_slot(action, trigger, scenario)
            elif 'drop_checkpt_stmts' in action:
                self.failures[PENDING].setdefault(self.configuration_number, []).append(scenario)
            elif 'change_operation' in action:
                output('Failure scenario', scenario,'encountered. It wont have any effect', level=logging.INFO)

        self.configuration = config
        self.configuration_number = config_no
        output('received config from olympus', level=logging.INFO)
        output('config num is', self.configuration_number, level=logging.INFO)

    def eval_request(request_id, request):
        result = self.state_object.evaluate_request(request)
        client_id = request_id.split('_')[0]
        self.last_evaluated_result[client_id] = result
        self.last_evaluated_request_id[client_id] = request_id
        return result

    def handle_new_request(request_id, request, retransmitted, signed_request):
        output('received new request', request, 'with id', request_id, level=logging.INFO)
        event = 'forwarded_request' if retransmitted else 'client_request'
        action, trigger, scenario = check_failure_scenario(request_id=request_id, event=event)
        if self.mode != Modes.ACTIVE or not lower_numbered_slots_present(self.slot):
            # holes present in history
            output('Mode is not active or there are holes in history. checked for slot', self.slot, 'sending reconfiguration request', level=logging.CRITICAL)
            send(('reconfiguration_request', None, self.replica_id), to=self.olympus)
            return

        operation = request
        ok_hash = ''
        if action:
            if 'change_result' in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                ok_hash = crypto_hash('OK')
            elif 'crash' in action:
                inject_crash(action, trigger, scenario)
            elif 'sleep' in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                time.sleep(float(action.strip('sleep()'))/1000.0)
            elif 'drop' in action and 'drop_checkpt_stmts' not in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                return
            elif 'extra_op' in action:
                inject_extra_op(action, trigger, scenario)
            elif 'increment_slot' in action:
                inject_increment_slot(action, trigger, scenario)
            elif 'drop_checkpt_stmts' in action:
                self.failures[PENDING].setdefault(self.configuration_number, []).append(scenario)

        pending = False
        for failure in self.failures[PENDING].get(self.configuration_number, []):
            output('checking for change_opeattion in', failure, level=logging.INFO)
            if 'change_operation' in failure:
                scenario = failure
                pending = True
                break
        output('pending is', pending, level=logging.INFO)
        if (action and 'change_operation' in action) or pending:
            pending_to_injected(scenario)
            operation = "get('x')"

        order_statement = ('order', self.slot+1, operation, self.replica_id)
        signed_order_statement = sign(order_statement)  # sign order statement

        result = eval_request(request_id, request)
        #output('result of request', request, ' is ', result, level=logging.INFO)
        #output('state object at this moment is', level=logging.INFO)
        #print_state_object()
        order_proof = (self.slot+1, request_id, request, self, self.configuration,
                       [signed_order_statement], signed_request)
        self.history.append(order_proof)
        self.slot += 1
        result_hash = ok_hash or crypto_hash(result)
        signed_result_proof = [sign(('result', request_id, operation,
                                     self.replica_id, result_hash))]
        shuttle = (order_proof, signed_result_proof)
        #output('sending shuttle to', self.configuration[self.position + 1], level=logging.INFO)
        send(('shuttle', shuttle), to=self.configuration[self.position + 1])

        # checkpointing
        if checkpt_interval != 0 and self.slot % checkpt_interval == 0:
            output('CPT !! initiating checkpoint shuttle. current slot is', self.slot, 'hash is',
                   crypto_hash(json.dumps(self.state_object.state, sort_keys=True)), level=logging.INFO)
            checkpt_stmt = sign(('checkpoint', crypto_hash(json.dumps(self.state_object.state, sort_keys=True)), self.replica_id))
            checkpt_shuttle = [checkpt_stmt]
            send(('checkpt_shuttle', checkpt_shuttle), to=self.configuration[self.position + 1])

    # message handler for receiving requests either from client or retransmitted ones from replicas
    def receive(msg=('request', signed_request), from_=sender):
        # signed_request = sign((request_id, self.client_id, request, is_retrasmitted))
        decoded_req = ast.literal_eval(signed_request.message.decode())
        if not verify(signed_request, decoded_req[1], type="client"):
            output('signature verification failed for request', decoded_req[0], level=logging.INFO)
            return
        else:
            request_id = decoded_req[0]
            request = decoded_req[2]
            retransmitted = decoded_req[3]
        output("received request with id", request_id, "retransmitted", retransmitted, "from", sender,
               level=logging.INFO)
        client_no = int(request_id.split('_')[0].strip('client'))
        if not retransmitted:
            self.client_requests_tracker[client_no][FailureScenarios.CLIENT_REQUEST] += 1
            handle_new_request(request_id, request, retransmitted, signed_request)
        # retransmitted request scenario
        else:
            if sender in self.configuration:
                # received forwarded request from another replica
                self.client_requests_tracker[client_no][FailureScenarios.FORWARDED_REQUEST] += 1
            else:
                self.client_requests_tracker[client_no][FailureScenarios.CLIENT_REQUEST] += 1

            if self.mode == Modes.IMMUTABLE:
                output('Replica is in immutable mode. Ignoring client request', level=logging.INFO)
                return  # TODO: return error
            elif is_correct(self) and request_id in self.result_cache:
                output('result already in cache. send result to client', level=logging.INFO)
                client = clients[request_id.split('_')[0]]
                cached_result = self.result_cache[request_id]
                send(('result', cached_result[0], cached_result[1]), to=client)
            elif self.position != 0: # not head
                output('current position is not head. so forward request to head', level=logging.INFO)
                send(('request', request_id, request, 1), to= self.configuration[0])
                await_for_result(request_id, 'nonhead-timeout') # passing id to know which timer expired
            else:
                if is_request_pending(request_id): # Head has seen the request
                    await_for_result(request_id, 'head-timeout pending request')
                else: # head has not seen this request
                    output('not seen this request before. treat as new request', level=logging.INFO)
                    handle_new_request(request_id, request, retransmitted, signed_request)
                    await_for_result(request_id, 'head-timeout resent new request')

        #send('done', to=self)

    # message handler for receiving shuttle going forward in the chain
    def receive(msg=('shuttle', shuttle), from_=predeccessor):
        output('received shuttle', shuttle, 'from', predeccessor, level=logging.INFO)
        # order_proof = (self.slot + 1, request_id, request, self, self.configuration,
        #                [signed_order_statement], signed_request)
        signed_request = shuttle[0][6]
        decoded_req = ast.literal_eval(signed_request.message.decode())
        if not verify(signed_request, decoded_req[1], type="client"):
            output('signature verification failed for request', decoded_req[0], level=logging.INFO)
            return
        #self.slot = shuttle[0][0]
        request_id = shuttle[0][1]
        request = shuttle[0][2]

        client_no = int(request_id.split('_')[0].strip('client'))
        self.client_requests_tracker[client_no][FailureScenarios.SHUTTLE] += 1
        action, trigger, scenario = check_failure_scenario(request_id=request_id, event='shuttle')
        if not is_shuttle_valid(shuttle):
            output('order proof invalid. sending reconfiguration request', level=logging.CRITICAL)
            send(('reconfiguration_request', None, self.replica_id), to=self.olympus)
            return
        if not lower_numbered_slots_present(self.slot):
            # holes present in history
            output('holes in history. checked for slot', self.slot, 'sending reconfiguration request', level=logging.CRITICAL)
            send(('reconfiguration_request', None, self.replica_id), to=self.olympus)
            return
        operation = request
        ok_hash = ''
        if action:
            if 'change_result' in action:
                ok_hash = crypto_hash('OK')
            elif 'drop_result_stmt' in action:
                shuttle[1].pop(0)
            elif 'crash' in action:
                inject_crash(action, trigger, scenario)
            elif 'sleep' in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                time.sleep(float(action.strip('sleep()'))/1000.0)
            elif 'drop' in action and 'drop_checkpt_stmts' not in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                return
            elif 'extra_op' in action:
                inject_extra_op(action, trigger, scenario)
            elif 'increment_slot' in action:
                inject_increment_slot(action, trigger, scenario)
            elif 'drop_checkpt_stmts' in action:
                self.failures[PENDING].setdefault(self.configuration_number, []).append(scenario)
                output('!! put in failures pending', self.failures, level=logging.INFO)

        pending = False
        for failure in self.failures[PENDING].get(self.configuration_number, []):
            output('checking for change_opeattion in', failure, level=logging.INFO)
            if 'change_operation' in failure:
                scenario = failure
                pending = True
                break
        output('pending is', pending, level=logging.INFO)
        if (action and 'change_operation' in action) or pending:
            pending_to_injected(scenario)
            operation = "get('x')"

        order_statement = ('order', self.slot+1, operation, self.replica_id)
        signed_order_statement = sign(order_statement) # sign order statement
        result = self.state_object.evaluate_request(request)
        #output('result of request', request, 'is', result, level=logging.INFO)
        #output('state object at this moment is', level=logging.INFO)
        #print_state_object()
        shuttle[0][5].append(signed_order_statement)

        result_hash = ok_hash or crypto_hash(result)
        result_statement = sign(('result', request_id, operation, self.replica_id, result_hash))
        shuttle[1].append(result_statement)
        self.history.append(shuttle[0]) # appending order proof to history
        self.slot += 1

        if self.position != len(self.configuration)-1:   # it is not tail replica
            send(('shuttle', shuttle), to=self.configuration[self.position+1])
        else:
            output('tail will send result to client for request id', request_id, level=logging.INFO)
            client = clients[request_id.split('_')[0]]
            send(('result', result, shuttle[1], request_id), to=client)
            self.result_cache[request_id] = (result, shuttle[1])
            if self.position != 0:
                send(('result_shuttle', result, shuttle), to=self.configuration[self.position-1])

    # message handler for receiving result shuttle going backward in the chain
    def receive(msg= ('result_shuttle', result, shuttle), from_=successor):

        output('received result shuttle', shuttle, 'from', successor, level=logging.INFO)
        request_id = shuttle[0][1]
        request = shuttle[0][2]
        client_no = int(request_id.split('_')[0].strip('client'))
        self.client_requests_tracker[client_no][FailureScenarios.RESULT_SHUTTLE] += 1
        action, trigger, scenario = check_failure_scenario(request_id=request_id, event='result_shuttle')

        if not is_result_shuttle_valid(result, shuttle):
            output('shuttle validation failed. sending reconfiguration request', level=logging.CRITICAL)
            send(('reconfiguration_request', None, self.replica_id), to=self.olympus)
            return

        if action:
            output('trigger failure scenario detected, action is to', action, level=logging.DEBUG)
            if 'change_operation' in action:
                output('trigger failure scenario detected, action', action, 'is invalid. ignoring failure.',
                       level=logging.INFO)
            elif 'change_result' in action:
                decoded_message = ast.literal_eval(shuttle[1][self.position].message.decode())
                op = decoded_message[2]
                shuttle[1][self.position] = sign(('result', request_id, op, self.replica_id, crypto_hash('OK')))
            elif 'drop_result_stmt' in action:
                shuttle[1].pop(0)
            elif 'crash' in action:
                inject_crash(action, trigger, scenario)
            elif 'sleep' in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                time.sleep(float(action.strip('sleep()'))/1000.0)
            elif 'drop' in action and 'drop_checkpt_stmts' not in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                return
            elif 'extra_op' in action:
                inject_extra_op(action, trigger, scenario)
            elif 'increment_slot' in action:
                inject_increment_slot(action, trigger, scenario)
            elif 'drop_checkpt_stmts' in action:
                self.failures[PENDING].setdefault(self.configuration_number, []).append(scenario)

        self.result_cache[request_id] = (result, shuttle[1])
        if self.position != 0:
            send(('result_shuttle', result, shuttle), to=self.configuration[self.position - 1])
        output('received result shuttle from ', successor, level=logging.INFO)

    # message handler for receiving checkpt shuttle going forward in the chain
    def receive(msg= ('checkpt_shuttle', checkpt_shuttle)):
        # To test checkpoint code for reconfig
        # if self.slot > 11 and self.position == 2:
        #     send(('reconfiguration_request', None, self.replica_id), to=self.olympus)
        self.message_tracker[FailureScenarios.CHECKPOINT] += 1
        output('CPT !! received checkpt shuttle. position is', self.position, 'slot is', self.slot,
               'len of history is', len(self.history), level=logging.INFO)
        await(len(self.history) >= checkpt_interval)
        action, trigger, scenario = check_failure_scenario()
        if action:
            pending_scenarios_type = ['change_operation', 'drop_checkpt_stmts']
            pending_scen_type = [scen_type for scen_type in pending_scenarios_type if scen_type in action]
            if pending_scen_type:
                put_in_pending(scenario)
            elif 'crash' in action:
                inject_crash(action, trigger, scenario)
            elif 'sleep' in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                time.sleep(float(action.strip('sleep()')) / 1000.0)
            elif 'drop' in action and 'drop_checkpt_stmts' not in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                return
            elif 'extra_op' in action:
                inject_extra_op(action, trigger, scenario)
            elif 'increment_slot' in action:
                inject_increment_slot(action, trigger, scenario)
            # elif 'drop_checkpt_stmts' in action:
            #     self.failures[PENDING].setdefault(self.configuration_number, []).append(scenario)

        checkpt_stmt = sign(('checkpoint', crypto_hash(json.dumps(self.state_object.state, sort_keys=True)), self.replica_id))
        checkpt_shuttle.append(checkpt_stmt)

        if self.position != len(self.configuration) - 1:  # it is not tail replica
            send(('checkpt_shuttle', checkpt_shuttle), to=self.configuration[self.position + 1])
        else:
            if is_checkpt_shuttle_valid(checkpt_shuttle):
                del self.history[:checkpt_interval]
                self.last_checkpoint_proof = checkpt_shuttle
                self.checkpointed_slot += checkpt_interval
            if self.position != 0:
                send(('checkpt_proof', checkpt_shuttle), to=self.configuration[self.position-1])

    def receive(msg= ('checkpt_proof', checkpt_proof)):

        self.message_tracker[FailureScenarios.COMPLETED_CHECKPOINT] += 1
        output('CPT !! received checkpt proof - ', checkpt_proof, level=logging.INFO)
        output('CPT !! received checkpt proof. position is', self.position, 'slot is', self.slot,
               'len of history is', len(self.history), level=logging.INFO)
        action, trigger, scenario = check_failure_scenario()
        if action:
            pending_scenarios_type = ['change_operation']
            pending_scenario = [scen_type for scen_type in pending_scenarios_type if scen_type in action]
            if pending_scenario:
                put_in_pending(scenario)
            elif 'crash' in action:
                inject_crash(action, trigger, scenario)
            elif 'sleep' in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                time.sleep(float(action.strip('sleep()')) / 1000.0)
            elif 'drop' in action and 'drop_checkpt_stmts' not in action:
                output('trigger failure scenario encountered, action is to', action, level=logging.CRITICAL)
                return
            elif 'extra_op' in action:
                inject_extra_op(action, trigger, scenario)
            elif 'increment_slot' in action:
                inject_increment_slot(action, trigger, scenario)

        if is_checkpt_proof_shuttle_valid(checkpt_proof):
            del self.history[:checkpt_interval]
            #self.slot -= checkpt_interval
            self.last_checkpoint_proof = checkpt_proof
            self.checkpointed_slot += checkpt_interval
            output('CPT !! checkpointed slot updated to', self.checkpointed_slot, 'last_checkpoint_proof is',
                   self.last_checkpoint_proof, level=logging.INFO)
            output('CPT !! updated history is', self.history, level=logging.INFO)
        else:
            output('checkpt proof validation failed', level=logging.CRITICAL)
            return

        if self.position != 0:
            pending=False
            for failure in self.failures[PENDING].get(self.configuration_number, []):
                if 'drop_checkpt_stmts' in failure:
                    scenario = failure
                    pending = True
                    break

            if (action and 'drop_checkpt_stmts' in action) or pending:
                pending_to_injected(scenario)
                t = int((len(self.configuration)-1)/2)
                send(('checkpt_proof', checkpt_proof[t+1:]), to=self.configuration[self.position - 1])
            else:
                send(('checkpt_proof', checkpt_proof), to=self.configuration[self.position-1])

    def run():
        await(received(('done')))
        output("replica: run finished")

    def await_for_result(request_id, timeout_id):
        if await(request_id in self.result_cache):
            client = clients[request_id.split('_')[0]]
            cached_result = self.result_cache[request_id]
            send(('result', cached_result[0], cached_result[1]), to=client)
        elif timeout(self.TIMER_DURATION):
            output('sending reconfiguration request to olympus', timeout_id, level=logging.CRITICAL)
            send(('reconfiguration_request', None, self.replica_id), to=self.olympus)

    def lower_numbered_slots_present(slt):
        if not slt:
            return True

        slot_itr = self.checkpointed_slot+1
        for op in self.history:
            output('checking lower slots. op', op[0], 'slot_itr', slot_itr, level=logging.INFO)
            if op[0] != slot_itr:
                return False
            slot_itr+=1
        return self.checkpointed_slot + len(self.history) == slt

    # this function checks if failure needs to be triggered on events
    def check_failure_scenario(request_id=None, event=None):
        output('checking for failure scenarios with respect to request id', request_id, 'for event', event,
               level=logging.INFO)
        client_no = int(request_id.split('_')[0].strip('client')) if request_id else None
        output('failure scenarios current config num', self.configuration_number, 'are', failure_scenarios, 'client no', client_no, level=logging.INFO)
        if failure_scenarios and failure_scenarios.get(self.configuration_number):
            scenarios = failure_scenarios[self.configuration_number].split(';')
            if not scenarios:
                return False, None, None

            for probable_fail_scen in self.message_tracker:
                m = self.message_tracker[probable_fail_scen]
                search_str = probable_fail_scen.value + '(' + str(m) + ')'
                #output('message tracker, search str is', search_str, level=logging.INFO)
                for scenario in scenarios:
                    if search_str in scenario and scenario.startswith(probable_fail_scen.value) and \
                                    scenario not in self.failures[INJECTED].get(self.configuration_number, []) and \
                                    scenario not in self.failures[PENDING].get(self.configuration_number, []):
                        #self.failures[PENDING].setdefault(self.configuration_number, []).append(search_str)
                        output('FAIL ! Detected failure scenario', scenario, 'action is to', scenario.split(search_str+',')[1],
                               level=logging.CRITICAL)
                        return scenario.split(search_str+',')[1], search_str, scenario

            if client_no is None:
                return False, None, None
            for probable_fail_scen in self.client_requests_tracker[client_no]:
                m = self.client_requests_tracker[client_no][probable_fail_scen]
                search_str = '(' + str(client_no) + ',' + str(m) + '),'
                for scenario in scenarios:
                    scenario = scenario.strip(' ')
                    if search_str in scenario and scenario.startswith(event) and \
                        scenario not in self.failures[INJECTED].get(self.configuration_number, []) and \
                        scenario not in self.failures[PENDING].get(self.configuration_number, []):
                        output('FAIL ! Detected failure scenario', scenario, 'action to be taken', scenario.split(search_str)[1],
                               level=logging.CRITICAL)
                        return scenario.split(search_str)[1], event+search_str, scenario
        return False, None, None

    def put_in_pending(scenario):
        self.failures[PENDING].setdefault(self.configuration_number, []).append(scenario)
        output('put scenario', scenario,'in pending. failures are', self.failures, level=logging.INFO)

    def pending_to_injected(scenario):
        try:
            self.failures.get(PENDING, []).get(self.configuration_number, []).remove(scenario)
            self.failures.get(INJECTED, []).setdefault(self.configuration_number, []).append(scenario)
            output('moving from pending to injected. failures are', self.failures, level=logging.INFO)
        except e:
            output("exception while moving failure scenario", scenario,"from pending to injected : ", str(e), level=logging.INFO)

    def inject_extra_op(action, trigger, scenario):
        request = "put('a','a')"
        self.state_object.evaluate_request(request)
        output('state object at this moment is', level=logging.INFO)
        print_state_object()

    def inject_increment_slot(action, trigger, scenario):
        if self.position == 0:
            self.slot += 1
            output('injecting increment slot, slot now is', self.slot, level=logging.INFO)

    def inject_crash(action, trigger, scenario):
        logging.shutdown()
        os._exit(-1)

    # if request is in history and not in result cache then it is pending
    def is_request_pending(req_id):
        request_order_proof = [op for op in self.history if op[1] == req_id]
        if len(request_order_proof) > 0 and req_id not in self.result_cache:
            output('request is pending..', level=logging.INFO)
            return True
        return False

    def is_correct(replica):
        return self.mode in [Modes.PENDING, Modes.ACTIVE, Modes.IMMUTABLE] \
               and is_history_valid(self.history)

    # verifies validity by checking every order statement
    def is_history_valid(hist):
        if len(hist) == 0: return True
        for order_proof in hist:
            request = order_proof[2]
            for ord_stmnt in order_proof[5]:
                decoded_message = ast.literal_eval(ord_stmnt.message.decode())
                request_from_order_statement = decoded_message[2]
                if request_from_order_statement != request:
                    return False
        return True

    def is_shuttle_valid(shuttle):
        # order_proof - (self.slot, request_id, request, self, self.configuration,
        #                   [signed_order_statement])
        order_proof = shuttle[0]
        request = order_proof[2]

        if len(order_proof[5]) != self.position:
            output('shuttle verification failed due to insufficient number of order statements',
                   level=logging.CRITICAL)
            return False
        # verify order proof for preceding replicas
        for ord_stmnt in order_proof[5]:
            # get replica id from order_statement
            decoded_message = ast.literal_eval(ord_stmnt.message.decode())
            rplca_id = decoded_message[3]
            request_from_order_statement = decoded_message[2]
            if not verify(ord_stmnt, rplca_id) or request_from_order_statement != request:
                output('order proof validation failed for replica', rplca_id, level=logging.CRITICAL)
                return False

        return True

    def receive(msg= ('get_state_obj'), from_=client):
        send(('state_object', self.state_object), to=client)

    # checks validity of result shuttle on backward traversal
    def is_result_shuttle_valid(result, shuttle):
        # result_proof - sign(('result', request_id, operation, self.replica_id, result_hash))

        order_proof = shuttle[0]
        request = order_proof[2]

        if len(order_proof[5]) != len(self.configuration):
            output('result shuttle verification failed due to insufficient number of order statements',
                   level=logging.CRITICAL)
            return False

        # verify order proof for preceding replicas
        for ord_stmnt in order_proof[5]:
            # get replica id from order_statement
            decoded_message = ast.literal_eval(ord_stmnt.message.decode())
            rplca_id = decoded_message[3]
            request_from_order_statement = decoded_message[2]
            if not verify(ord_stmnt, rplca_id) or request_from_order_statement != request:
                output('order proof validation failed for replica', rplca_id, level=logging.CRITICAL)
                return False

        result_hash = crypto_hash(result)
        result_proof = shuttle[1]

        if len(result_proof) != len(self.configuration):
            output('result shuttle verification failed due to insufficient number of result statements',
                   level=logging.CRITICAL)
            return False

        for replica_result_proof in result_proof:
            decoded_message = ast.literal_eval(replica_result_proof.message.decode())
            rplca_id = decoded_message[3]
            rplca_result_hash = decoded_message[4]
            if not verify(replica_result_proof, rplca_id) or result_hash != rplca_result_hash:
                output('result shuttle verification failed for replica', rplca_id, level=logging.CRITICAL)
                return False

        return True

    def is_checkpt_proof_shuttle_valid(checkpt_proof):

        if len(checkpt_proof) != len(self.configuration):
            output('checkpt shuttle verification failed due to insufficient number of checkpt statements',
                   level=logging.CRITICAL)
            return False

        state_hash = None
        for checkpt in checkpt_proof:
            decoded_message = ast.literal_eval(checkpt.message.decode())
            rplca_id = decoded_message[2]
            rplca_state_hash = decoded_message[1]
            state_hash = rplca_state_hash if state_hash is None else state_hash
            if not verify(checkpt, rplca_id) or rplca_state_hash != state_hash:
                output('checkpt shuttle verification failed for replica', rplca_id, level=logging.CRITICAL)
                return False

        return True

    def is_checkpt_shuttle_valid(checkpt_shuttle):
        return True


def main():
    pass