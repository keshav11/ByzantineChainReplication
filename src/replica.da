from src.object import Object
from enum import Enum
import nacl.signing
import nacl.encoding
import nacl.hash
import nacl.exceptions
import ast

class Modes(Enum):
    ACTIVE = 0
    PENDING = 1
    IMMUTABLE = 2


class Replica(process):

    def setup(replica_id:str, position:int, crypto_keys:tuple, clients, timeout):
        self.all_replicas_public_keys = {}
        self.state_object = Object()
        self.history = []
        self.olympus = None
        self.mode = Modes.PENDING
        self.slot = 0
        self.configuration = []
        self.position = position
        self.result_cache = {}
        self.replica_id = replica_id
        self.TIMER_DURATION = timeout

    def sign(data):
        return crypto_keys[0].sign(str(data).encode())

    def receive(msg= ('olympus', olympus)):
        self.olympus = olympus
        output('olympus received in client-', self.olympus)

    def verify(data, replica_id):
        v_key = nacl.signing.VerifyKey(self.all_replicas_public_keys[replica_id],
                                       encoder=nacl.encoding.HexEncoder)
        try:
            v_key.verify(data.message,data.signature)
        except nacl.exceptions.BadSignatureError:
            return False

        output('signature verified')
        return True

    def crypto_hash(data):
        return nacl.hash.sha256(data.encode(), encoder=nacl.encoding.HexEncoder)

    def print_state_object():
        for key in self.state_object.state:
            print(key, '->', self.state_object.state[key])

    def receive(msg= ('all_replicas_public_keys', all_replicas_public_keys)):
        self.all_replicas_public_keys = all_replicas_public_keys
        output("replica: receive all_replicas_public_keys finished")

    def receive(msg=('inithist', history)):
        output('receive handler for inithist')
        self.history = history
        self.mode = Modes.ACTIVE

    def receive(msg=('config', config)):
        output('receiving config from olympus')
        self.configuration = config

    def lower_numbered_slots_present(slt):
        slot_itr = 1
        for op in self.history:
            if op[0] != slot_itr:
                return False
            slot_itr+=1
        return slot_itr == slt

    def handle_new_request(request_id, request_id, request):
        output("new request", request_id, level=20)
        self.slot += 1
        if self.mode != Modes.ACTIVE or not lower_numbered_slots_present(self.slot):
            # holes in history present
            output('slots missing in history..')
            output('order proof invalid. send reconfiguration request')
            send(('reconfiguration-request', self), to=self.olympus)

        # TODO - add conditions like mode is active and all lower numbered slots etc
        output('head sending replica id as ', self.replica_id)
        if len(self.history) < self.slot:
            order_statement = ('order', self.slot, request, self.replica_id)
            signed_order_statement = sign(order_statement)  # sign order statement
        # else:
        #    return error
        result = self.state_object.evaluate_request(request)
        output('result of request ', request, ' is ', result)
        output('state object at this moment is ')
        print_state_object()
        order_proof = (self.slot, request_id, request, self, self.configuration,
                       [signed_order_statement])
        self.history.append(order_proof)
        # TODO - hash of result and sign the proof
        signed_result_proof = [sign(('result', request_id, request, crypto_hash(result)))]
        shuttle = (order_proof, signed_result_proof)
        output('sending shuttle to ', self.configuration[self.position + 1])
        send(('shuttle', shuttle), to=self.configuration[self.position + 1])

    def receive(msg=('request', request_id, request, retransmitted)):
        output("received request with id ", request_id)
        if not retransmitted:
            handle_new_request(request_id, request)
        else: # retransmitted request
            output("retransmitted request received...", level= 20)
            if is_correct(self) and request_id in self.result_cache:
                output('result already in cache. send result to client', level= 20)
                client = clients[request_id.split('_')[0]]
                cached_result = self.result_cache[request_id]
                send(('result', cached_result[0], cached_result[1]), to=client)
            elif self.mode == Modes.IMMUTABLE:
                pass  # TODO: return error
            elif self.position != 0: # not head
                output('current position is not head. so forward request to head', level= 20)
                send(('request', request_id, request, 1), to= self.configuration[0])
                await_for_result(request_id, 'nonhead-timeout') # passing id to know which timer expired
            else:
                output('current position is head.', level= 20)
                if is_request_pending(request_id): # Head has seen the request
                    await_for_result(request_id, 'head-timeout pending request')
                else: # head has not seen this request
                    output('not seen this request before. treat as new request', level= 20)
                    handle_new_request(request_id, request)
                    await_for_result(request_id, 'head-timeout resent new request')

        send('done', to=self) # REMOVE ME

    def await_for_result(request_id, timeout_id):
        #if await(some(received(('result_shuttle', _, _, r_id)), has=r_id == request_id)):  # TODO: FIXME with merged code
        if await(request_id in self.result_cache):  # TODO: FIXME with merged code
            client = clients[request_id.split('_')[0]]
            cached_result = self.result_cache[request_id]
            send(('result', cached_result[0], cached_result[1]), to=client)
        elif timeout(self.TIMER_DURATION):
            output('sending reconfiguration request to olympus', timeout_id, 'position-',
                   self.position, level=20)
            send(('reconfiguration-request', self), to=self.olympus)

    def is_request_pending(req_id):
        request_order_proof = [op for op in self.history if op[1] == req_id]
        if len(request_order_proof) > 0 and req_id not in self.result_cache:
            output('request is pending..', level= 20)
            return True
        return False

    def is_correct(replica):
        return self.mode in [Modes.PENDING, Modes.ACTIVE, Modes.IMMUTABLE] \
               and is_history_valid(self.history)

    def is_history_valid(hist):
        if len(hist) == 0: return True
        for order_proof in hist:
            request = order_proof[2]
            for ord_stmnt in order_proof[5]:
                decoded_message = ast.literal_eval(ord_stmnt.message.decode())
                request_from_order_statement = decoded_message[2]
                if request_from_order_statement != request:
                    return False
        return True

    def receive(msg=('shuttle', shuttle), from_=predeccessor):
        # TODO - do the replicas compare result with predeccessor
        # TODO - check validity
        output('received shuttle from ', predeccessor)
        if not is_order_proof_valid(shuttle[0]):
            output('order proof invalid. send reconfiguration request')
            send(('reconfiguration-request', self), to=self.olympus)
        self.slot = shuttle[0][0]  # get slot from shuttle
        if not lower_numbered_slots_present(self.slot):
            # holes in history present
            output('slots missing in history..')
            output('order proof invalid. send reconfiguration request')
            send(('reconfiguration-request', self), to=self.olympus)
        request_id = shuttle[0][1]
        request = shuttle[0][2]
        order_statement = ('order', self.slot, request, self.replica_id)
        signed_order_statement = sign(order_statement) # sign order statement
        result = self.state_object.evaluate_request(request)
        output('result of request ', request, ' is ', result)
        output('state object at this moment is ')
        print_state_object()

        shuttle[0][5].append(signed_order_statement)

        result_statement = ('result', request_id, request, crypto_hash(result))
        shuttle[1].append(result_statement)
        self.history.append(shuttle[0]) # appending order proof to history

        if self.position != len(self.configuration)-1:   # it is not tail replica
            #output('sending shuttle to ', self.configuration[self.position+1])
            send(('shuttle', shuttle), to=self.configuration[self.position+1])
        else:
            output('tail will send result to client...', level= 20)
            client = clients[request_id.split('_')[0]]
            send(('result', result, shuttle[1]), to=client)
            # TODO - is the full shuttle cached or just result proof
            self.result_cache[request_id] = (result, shuttle[1])
            if self.position != 0:
                send(('result_shuttle', result, shuttle), to=self.configuration[self.position-1])

    def receive(msg= ('result_shuttle', result, shuttle), from_=successor):
        # TODO - should replica recalculate the result instead of taking tail's result
        # TODO - is the full shuttle cached or just result proof
        request_id = shuttle[0][1]
        self.result_cache[request_id] = (result, shuttle[1])
        if self.position != 0:
            send(('result_shuttle', result, shuttle), to=self.configuration[self.position - 1])
        output('received result shuttle from ', successor)

    def run():
        await(received(('done')))
        await(received('request',))
        output("replica: run finished")

    def is_order_proof_valid(order_proof):
        # order_proof - (self.slot, request_id, request, self, self.configuration,
        #                   [signed_order_statement])
        request = order_proof[2]
        # verify order proof for preceding replicas
        for ord_stmnt in order_proof[5]:
            # get replica id from order_statement
            decoded_message = ast.literal_eval(ord_stmnt.message.decode())
            rplca_id = decoded_message[3]
            request_from_order_statement = decoded_message[2]
            if not verify(ord_stmnt, rplca_id) and request_from_order_statement != request:
                return False
        return True

def main():
    pass