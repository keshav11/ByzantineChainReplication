import time
import sys
import logging
import nacl.signing
import nacl.encoding
import nacl.hash
import nacl.exceptions
import ast


class Client(process):
    def setup(client_id, workload, timeout):
        self.all_replicas_public_keys = {}
        output("client setup")
        self.olympus = None
        self.configuration = None
        self.configuration_number = -1
        self.head = None
        self.tail = None
        self.TIMER_DURATION = timeout
        self.crypto_keys = None

    def receive(msg= ('cypto_keys', crypto_keys)):
        self.crypto_keys = crypto_keys
        output('crypto keys received from olympus')

    def receive(msg= ('olympus', olympus)):
        self.olympus = olympus
        send(("olympus_received", self), to=self.olympus)

    def receive(msg= ('config', config, config_no)):
        self.configuration = config
        self.configuration_number = config_no
        """ TODO config validation"""
        self.head = self.configuration[0]
        self.tail = self.configuration[-1]

    def receive(msg= ('result', result, result_proof, request_id)):
        if not validate(result, result_proof):
            output('client: result proof validation failed.'
                   ' send reconfiguration request')
            send(('reconfiguration-request', self), to=self.olympus)
        output('received result for request id', request_id, result)

    def receive(msg= ('all_replicas_public_keys', all_replicas_public_keys)):
        self.all_replicas_public_keys = all_replicas_public_keys
        output("client: receive all_replicas_public_keys finished")

    def fetch_config():
        send(('get_config', self), to=self.olympus)
        await(received(('config',self.configuration, self.configuration_number)))

    def crypto_hash(data):
        return nacl.hash.sha256(data.encode(), encoder=nacl.encoding.HexEncoder)

    def verify(data, replica_id):
        v_key = nacl.signing.VerifyKey(self.all_replicas_public_keys[replica_id],
                                       encoder=nacl.encoding.HexEncoder)
        try:
            v_key.verify(data)
        except nacl.exceptions.BadSignatureError:
            return False
        except Exception:
            return False

        output('signature verified', level=logging.DEBUG)
        return True

    def sign(data):
        return crypto_keys[0].sign(str(data).encode())

    def validate(result, result_proof):
        output('validating result...')
        result_hash = crypto_hash(result)
        count = 0
        for replica_result_proof in result_proof:
            decoded_message = ast.literal_eval(replica_result_proof.message.decode())
            rplca_id = decoded_message[3]
            if not verify(replica_result_proof, rplca_id):
                output('signature validation failed for replica_id', rplca_id)
                return False
            if decoded_message[4] == result_hash:
                count += 1
            else:
                output('result hash is different for',rplca_id, level=logging.CRITICAL)

        t = (len(self.configuration) - 1)/2
        # TODO - should it check for all?
        return count >= (t+1)

    def run():
        output("waiting for olympus to contact...")
        await(received(('olympus', self.olympus)))
        output("received olympus ", self.olympus)
        fetch_config()
        output("received config from olympus ", self.configuration)

        workload = list(filter(None, workload.split(';'))) #TODO - remove empty
        for i in range(len(workload)):
            request = workload[i].strip()
            request_id = client_id + '_' + str(i)
            send_request(request_id, request, 0, self.head)
            output('waiting for result of request id', request_id)
            if await(some(received(('result', _, _, r_id)), has= r_id==request_id)):
                output('await se nikal liya !!!!!')
                pass
            # if await(received(('result', self.result, self.result_proof)) and validate(self.result, self.result_proof)):
            #     output('await se nikal liya !!!!!')
            #     pass
            elif timeout(self.TIMER_DURATION):
                output('timeout occurred for message request_id', request_id)
                fetch_config()
                for replica in self.configuration:
                    send_request(request_id, request, 1, replica)
                await(some(received(('result', _, _, r_id)), has=r_id == request_id))

            #await(len(listof(self.tail, received(('result', _, _), from_=self.tail))) == i+1)
            #await(len(some(received(('result', _, _)))) == i+1)
            #await(setof(a, received(('result', _, a)), request in a[0]))
            #await(each(req in range(i+1), has= some(received(('result', _, _)))))
            #await(received(('result', self.result, self.result_proof)) and validate(self.result, self.result_proof))

        await(received(('done')))
        output('client run finished!')

    def send_request(request_id, request, is_retrasmitted, recipient):
        output("sending request with id ", request_id, " and request workload ", request, "to", recipient)
        signed_request = sign((request_id, self.client_id, request, is_retrasmitted))
        send(('request', signed_request), to=recipient)


def main():
    pass