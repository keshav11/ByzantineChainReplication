replica_module = import_da('replica')
import nacl.signing
import nacl.encoding
import nacl.hash
import nacl.exceptions
import logging
import ast
import random
import time
import itertools

class Olympus(process):
    def setup(num_replica, clients, failure_scenarios, head_timeout, nonhead_timeout, t):
        self.all_replicas_public_keys = {}
        self.all_clients_public_keys = {}
        self.configuration = []  # current configuration
        self.replica_map = {}
        self.configuration_number = 0
        self.crypto_keys = None
        self.wedged_statements = []
        self.t = t
        self.caught_up_messages = []
        self.replica_running_state = None
        self.reconfiguration_in_process = False

    def sign(data):
        return crypto_keys[0].sign(str(data).encode('utf-8'))

    def verify(data, id=None, type="replica"):
        if type == "replica":
            v_key = nacl.signing.VerifyKey(self.all_replicas_public_keys[id],
                                           encoder=nacl.encoding.HexEncoder)
        else:
            v_key = nacl.signing.VerifyKey(self.all_clients_public_keys[id],
                                           encoder=nacl.encoding.HexEncoder)
        try:
            v_key.verify(data.message, data.signature)
        except nacl.exceptions.BadSignatureError:
            return False

        output('signature verified', level=logging.DEBUG)
        return True

    def crypto_hash(data):
        return nacl.hash.sha256(data.encode(), encoder=nacl.encoding.HexEncoder)

    def generate_keys():
        """TODO: genererate keys"""
        s_key = nacl.signing.SigningKey.generate()
        v_key = s_key.verify_key
        v_key_hex = v_key.encode(encoder=nacl.encoding.HexEncoder)
        return (s_key, v_key_hex)

    def get_decoded_msg(signed_msg):
        return ast.literal_eval(signed_msg.message.decode())

    def receive(msg=('get_config'), from_= client):
        send(('config', self.configuration, self.configuration_number, self.all_replicas_public_keys), to=client)

    def get_decoded_msg(signed_msg):
        return ast.literal_eval(signed_msg.message.decode())

    def receive(msg=('wedge-statement', wedged_stmnt), from_=sender):
        # send(('wedge-statement', sign((self.replica_id, self.history, self.last_checkpoint_proof))), to=self.olympus)
        output('received wedge statement from ', sender, level=logging.INFO)
        # TODO: sign
        #decoded_req = a
        #if not verify(wedged_stmnt, decoded_req[0]):
        #    output('signature verification failed for wedge statement from', level=logging.INFO)
        #    return
        #else:
        decoded_req = wedged_stmnt
        history =  decoded_req[1]
        last_checkpoint_proof = decoded_req[2]
        self.wedged_statements.append(wedged_stmnt)

    def receive(msg=('caught_up', caught_up_message), from_=sender):
        output('received caught up message from ', sender, level=logging.INFO)
        decoded_msg = get_decoded_msg(caught_up_message)
        if not verify(caught_up_message, decoded_msg[0]):
            output('signature verification failed for caught up message from', sender, level=logging.WARNING)
        else:
            output('caught up message,', decoded_msg)
            self.caught_up_messages.append(decoded_msg)
            # TODO: do the sending of pending result to client

    def receive(msg=('running_state', running_state), from_=sender):
        output('received running state from ', sender, level=logging.INFO)
        self.replica_running_state = running_state[1]
        # decoded_msg = get_decoded_msg(running_state)
        # if not verify(running_state, decoded_msg[0]):
        #     output('signature verification failed for running state message from', sender, level=logging.WARNING)
        # else:
        #     output('running state message,', decoded_msg)
        #     self.replica_running_state = decoded_msg[1]


    def receive(msg=('reconfiguration-request', proof_of_misbehaviour, sender_id), from_= sender):
        # if sender is not in current configuration and the proof of misbehaviour is
        # invalid, ignore
        output('received reconfiguration request from ', sender, level=logging.INFO)
        if reconfiguration_in_process: return
        reconfiguration_in_process = True
        if sender_id not in self.replica_map.keys() and (proof_of_misbehaviour == None or not
        check_proof_of_misbehaviour(proof_of_misbehaviour)):
            output('reconfiguration request not valid.', level=logging.INFO)
            return  # ignore request
        for replica in self.configuration:
            output('sending wedge request to ', replica, level=logging.INFO)
            send(('wedge-request'), to=replica)
        output(t)
        await(len(self.wedged_statements) >= (t+1))
        output('at least t+1 wedged statememnts received.-', len(self.wedged_statements))
        valid_quorum = False
        quorum = []
        while not valid_quorum:
            permutations = itertools.permutations(self.wedged_statements, t+1)
            for quorum_candidate in permutations:
                output('qc',len(quorum_candidate))
                if is_history_consistent(quorum_candidate):
                    quorum = quorum_candidate
                else:
                    continue
                longest_history = []
                longest_history_replica_id = ""
                for wdge_stmnt in quorum:
                    if len(wdge_stmnt[1]) > len(longest_history):
                        longest_history = wdge_stmnt[1]
                        longest_history_replica_id = wdge_stmnt[0]
                output(type(longest_history))
                output(longest_history_replica_id)
                longest_history_len = len(longest_history)
                for wedge_stmnt in quorum:
                    replica_id = wedge_stmnt[0]
                    replica_hist = list(filter(lambda a: a[0] == replica_id, quorum))[0][1]
                    replica_hist_len = len(replica_hist)
                    output('replica', replica_id, 'history is', replica_hist, 'of len',
                           replica_hist_len , level=logging.INFO)
                    output('sending catch_up request to ', replica_id, level=logging.INFO)
                    output('sending history to catch up', longest_history[replica_hist_len:], level=logging.INFO)
                    send(('catch_up', longest_history[replica_hist_len:]), to=self.replica_map[replica_id])

                await(len(self.caught_up_messages) == len(quorum))
                output('received', len(quorum), 'caught up messages', level=logging.INFO)
                # check if hash in caught_up_messages are same
                valid_quorum = True
                hash_val = self.caught_up_messages[0][1]
                for caught_up_msg in self.caught_up_messages:
                    if not caught_up_msg[1] == hash_val:
                        output('hash of state object do not match for ', caught_up_msg[0], level=logging.INFO)
                        valid_quorum = False
                        break
                if valid_quorum: break
            # check if new wedged statements have arrived
            -- wedgestatements

        output('valid quorum obtained-', quorum)

        hash_val = self.caught_up_messages[0][1]
        for wedge_stmnt in quorum:
            replica_id = wedge_stmnt[0]
            output('sending get_running state msg to ', replica_id, level=logging.INFO)
            send(('get_running_state'), to=self.replica_map[replica_id])
            await(self.replica_running_state is not None)
            if crypto_hash(self.replica_running_state) == hash_val:
                break
            else:
                self.replica_running_state = None

        terminate_all_replicas()
        output('running state', self.replica_running_state)
        create_configuration(self.replica_running_state)
        self.configuration_number += 1
        # reset
        self.reconfiguration_in_process = False
        self.wedged_statements = []
        self.replica_running_state = None

    def terminate_all_replicas():
        for replica in self.configuration:
            send(('done'), to=replica)
            send(('terminate'), to=replica)
        self.configuration = []
        self.all_replicas_public_keys = {}
        self.configuration = []  # current configuration
        self.replica_map = {}

    def is_history_consistent(quorum_candidate):
        return True

    def check_proof_of_misbehaviour(proof_of_misbehaviour):
        return True

    def create_configuration(state_obj=None):
        """ creating num_replica replicas """
        start_replicas(state_obj)
        send_client_public_keys_to_replicas()

    def run():
        self.crypto_keys = generate_keys()
        register_to_clients()
        create_configuration()
        # wait till done not received
        await(received(('done')))
        output('olympus run finished!')

    def send_client_public_keys_to_replicas():
        output('sending all_clients_public_keys to replicas')
        for replica in self.configuration:
            send(('all_clients_public_keys', self.all_clients_public_keys), to=replica)

    def register_to_clients():
        for cnt_id in clients:
            key_pair = generate_keys()
            self.all_clients_public_keys[cnt_id] = key_pair[1]
            send(('all_crypto_keys', self.crypto_keys[1],
                  key_pair, self.all_replicas_public_keys), to=clients[cnt_id])

    def start_replicas(state_obj):
        """start num_replicas replicas"""
        output("starting replicas...", level=logging.INFO)
        for itr in range(num_replica):
            key_pair = generate_keys()
            replica_id = 'replica' + str(itr)
            self.all_replicas_public_keys[replica_id] = key_pair[1]
            if itr == 0:
                timeout = self.head_timeout
            else:
                timeout = self.nonhead_timeout
            replica = new(replica_module.Replica, [replica_id, itr, key_pair,
                                                   clients, failure_scenarios.get(itr), timeout, self.crypto_keys[1], state_obj], num=1)
            self.configuration.append(replica)
            self.replica_map[replica_id] = replica
            start(replica)

        """send public keys and config to replica"""
        for replica in self.configuration:
            send(('inithist', sign([])), to=replica)
            send(('all_replicas_public_keys', sign(self.all_replicas_public_keys)), to=replica)
            send(('config', self.configuration, self.configuration_number), to=replica)

            send(('done',), to=replica)

        output("started all replicas", level=logging.INFO)


def main():
    olympus = new(Olympus, [1, 1])
    start(olympus)
