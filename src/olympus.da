replica_module = import_da('replica')
import nacl.signing
import nacl.encoding
import nacl.hash
import nacl.exceptions
import logging
import ast
import random
import time
import itertools
import pickle

class Olympus(process):
    def setup(num_replica, clients, failure_scenarios, head_timeout, nonhead_timeout, checkpt_interval, t, bcr_main):
        self.all_replicas_public_keys = {}
        self.all_clients_public_keys = {}
        self.configuration = []  # current configuration
        self.replica_map = {}
        self.configuration_number = 0
        self.crypto_keys = None
        self.wedged_statements = []
        self.t = t
        self.caught_up_messages = []
        self.replica_running_state = None
        self.reconfiguration_in_process = False
        self.num_clients_finished = 0

    def sign(data):
        return crypto_keys[0].sign(str(data).encode())

    def verify(data, id=None, type="replica"):
        if type == "replica":
            v_key = nacl.signing.VerifyKey(self.all_replicas_public_keys[id],
                                           encoder=nacl.encoding.HexEncoder)
        else:
            v_key = nacl.signing.VerifyKey(self.all_clients_public_keys[id],
                                           encoder=nacl.encoding.HexEncoder)
        try:
            v_key.verify(data)
        except nacl.exceptions.BadSignatureError:
            return False
        except:
            return False
        output('signature verified', level=logging.DEBUG)
        return True

    def crypto_hash(data):
        return nacl.hash.sha256(data.encode(), encoder=nacl.encoding.HexEncoder)

    def generate_keys():
        """TODO: genererate keys"""
        s_key = nacl.signing.SigningKey.generate()
        v_key = s_key.verify_key
        v_key_hex = v_key.encode(encoder=nacl.encoding.HexEncoder)
        return (s_key, v_key_hex)

    def get_decoded_msg(signed_msg):
        return ast.literal_eval(signed_msg.message.decode())

    def receive(msg=('get_config'), from_= client):
        await(self.reconfiguration_in_process is False)
        send(('config', self.configuration, self.configuration_number, self.all_replicas_public_keys), to=client)

    def receive(msg=('finished_execution'), from_=client):
        self.num_clients_finished += 1
        send(('done'), to=client)

    def receive(msg=('wedge_statement', wedged_stmnt), from_=sender):
        # send(('wedge_statement', sign((self.replica_id, self.history, self.last_checkpoint_proof))), to=self.olympus)
        output('received wedge statement from ', sender, level=logging.INFO)
        decoded_req = pickle.loads(get_decoded_msg(wedged_stmnt))
        if not verify(wedged_stmnt, decoded_req[0]):
           output('signature verification failed for wedge statement from', level=logging.INFO)
           return
        else:
            self.wedged_statements.append(decoded_req)

    def receive(msg=('caught_up', caught_up_message), from_=sender):
        output('received caught up message from ', sender, level=logging.INFO)
        decoded_msg = get_decoded_msg(caught_up_message)
        if not verify(caught_up_message, decoded_msg[0]):
            output('signature verification failed for caught up message from', sender, level=logging.CRITICAL)
        else:
            output('caught up message received-', decoded_msg, level=logging.INFO)
            self.caught_up_messages.append(decoded_msg)

    def receive(msg=('running_state', running_state), from_=sender):
        output('received running state from ', sender, level=logging.INFO)
        decoded_msg = pickle.loads(get_decoded_msg(running_state))
        if not verify(running_state, decoded_msg[0]):
            output('signature verification failed for running state message from', sender, level=logging.WARNING)
        else:
            output('running state message received', decoded_msg, level=logging.INFO)
            self.replica_running_state = decoded_msg[1]

    def receive(msg=('reconfiguration_request', proof_of_misbehaviour, sender_id), from_= sender):
        # if sender is not in current configuration and the proof of misbehaviour is
        # invalid, ignore
        output('received reconfiguration request from ', sender, level=logging.INFO)
        if self.reconfiguration_in_process:
            return
        if sender_id not in self.replica_map.keys() and (proof_of_misbehaviour == None or
            result_sent_by_client_valid(proof_of_misbehaviour)):
            output('reconfiguration request not valid.', level=logging.INFO)
            return  # ignore request
        self.reconfiguration_in_process = True
        for replica in self.configuration:
            output('sending wedge request to ', replica, level=logging.INFO)
            send(('wedge_request'), to=replica)
        await(len(self.wedged_statements) >= (self.t+1))
        output('at least t+1 wedged statememnts received. number of wedged statements received-', len(self.wedged_statements), level=logging.INFO)
        valid_quorum = False
        quorum = []
        while not valid_quorum:
            permutations = itertools.permutations(self.wedged_statements, self.t+1)
            for quorum_candidate in permutations:
                if is_history_consistent(quorum_candidate):
                    output('consistent quorum obtained', level=logging.INFO)
                    quorum = quorum_candidate
                else:
                    output('quorum candidate is not consistent. taking a different quorum', level=logging.INFO)
                    continue
                longest_history = []
                longest_history_replica_id = ""
                max_slot = -1

                for wedge_stmnt in quorum:
                    # calculate max list history (checkpointed_slot + len(history))
                    replica_hist = wedge_stmnt[1]
                    replica_hist_max_slots = len(replica_hist) + wedge_stmnt[3]
                    if replica_hist_max_slots > max_slot:
                        longest_history = replica_hist
                        max_slot = replica_hist_max_slots
                output('longest history is,', longest_history, level=logging.INFO)
                output('max number of slots present in history', max_slot)
                # ('wedge_statement' - (self.replica_id, self.history, self.last_checkpoint_proof, self.checkpointed_slot)
                #order_proof = (self.slot + 1, request_id, request, self, self.configuration, [signed_order_statement])
                for wedge_stmnt in quorum:
                    self.caught_up_messages = [] # empty it
                    replica_id = wedge_stmnt[0]
                    replica_hist = wedge_stmnt[1]
                    output('history for replica id,', replica_id, 'is', replica_hist, level=logging.INFO)
                    replica_hist_max_slots = len(replica_hist) + wedge_stmnt[3] # checkpointed_slot + len(history)
                    slots_behind = max_slot - replica_hist_max_slots
                    output('replica', replica_id, 'history has total slots',
                           replica_hist_max_slots, 'and is', slots_behind, 'slots behind' , level=logging.INFO)
                    history_to_catch_up = longest_history[(len(longest_history)-slots_behind):]
                    output('sending history to catch up', history_to_catch_up, 'to', replica_id, level=logging.INFO)
                    send(('catch_up', history_to_catch_up), to=self.replica_map[replica_id])
                await(len(self.caught_up_messages) == len(quorum))
                output('received', len(quorum), 'caught up messages', level=logging.INFO)
                # check if hash in caught_up_messages are same
                valid_quorum = True
                hash_val = self.caught_up_messages[0][1]
                for caught_up_msg in self.caught_up_messages:
                    if not caught_up_msg[1] == hash_val:
                        output('hash of state object do not match for ', caught_up_msg[0], level=logging.CRITICAL)
                        valid_quorum = False
                        break
                if valid_quorum: break
            # check if new wedged statements have arrived
            -- wedgestatements


        output('valid quorum obtained-', quorum, level=logging.INFO)
        valid_result_quorum = None
        # getting quorum of result statements sent by replicas
        results_to_send = {}
        request_ids = {}
        for client_id in clients:
            for res_quorum in itertools.permutations(self.caught_up_messages, self.t+1):
                if client_id not in res_quorum[0][2]:
                    break
                first_hash = crypto_hash(str(res_quorum[0][2][client_id]))
                count = 1
                for i in range(1,len(res_quorum)):
                    if client_id not in res_quorum[i][2] or \
                                    crypto_hash(str(res_quorum[i][2][client_id])) != first_hash:
                        break
                    else:
                        count += 1
                if count == self.t+1:
                    results_to_send[client_id] = res_quorum[0][2][client_id]
                    request_ids[client_id] = res_quorum[0][3][client_id]
                    break

        # output('-----------------------------------------------------------------------------', level=logging.INFO)
        # output(results_to_send, level=logging.INFO)
        # output(request_ids, level=logging.INFO)

        if len(results_to_send) > 0:
            output("valid client result quorum obtained", level=logging.INFO)
            for client_id in results_to_send:
                output("send result for", request_ids[client_id], 'to', client_id, level=logging.INFO)
                res = results_to_send[client_id]
                send(('result_olympus', sign((res, request_ids[client_id])), request_ids[client_id]), to=self.clients[client_id])

        hash_val = self.caught_up_messages[0][1]
        for wedge_stmnt in quorum:
            replica_id = wedge_stmnt[0]
            output('sending get_running state msg to ', replica_id, level=logging.INFO)
            send(('get_running_state'), to=self.replica_map[replica_id])
            await(self.replica_running_state is not None)
            if crypto_hash(self.replica_running_state) == hash_val:
                break
            else:
                self.replica_running_state = None

        terminate_all_replicas()
        output('running state', self.replica_running_state, level=logging.INFO)
        self.configuration_number += 1
        create_configuration(self.replica_running_state)
        # reset
        -- reconfigcomplete
        self.reconfiguration_in_process = False
        self.wedged_statements = []
        self.replica_running_state = None

    def is_history_consistent(wedged_statements):
        output('checking consistency of wedged_statements', wedged_statements, level=logging.INFO)
        # checking order proofs in each wedge statements
        for wedged_statement in wedged_statements:
            # TODO
            if not is_checkpoint_proof_shuttle_valid(wedged_statement[2]):
                return False
            for order_proof in wedged_statement[1]:
                if not is_order_proof_valid(order_proof):
                    return False
        for w1 in wedged_statements:
            for w2 in wedged_statements:
                if w1 == w2:
                    continue
                output('comparing history for wedged statements', w1, w2, logging.INFO)
                # ('wedge_statement' - (self.replica_id, self.history, self.last_checkpoint_proof, self.checkpointed_slot)
                checkpoint_diff = w1[3] - w2[3]
                if checkpoint_diff > 0:
                    w1_hist = w1[1]
                    w2_hist = w2[1][checkpoint_diff:]
                else:
                    w1_hist = w1[1][-checkpoint_diff:]
                    w2_hist = w2[1]
                for slot in range(0, min(len(w1_hist), len(w2_hist))):
                    if w2_hist[slot][2] != w2_hist[slot][2]:
                        output('history inconsistent', level=logging.WARNING)
                        return False
        return  True

    def is_order_proof_valid(order_proof):
        # order_proof = (self.slot + 1, request_id, request, self, self.configuration,
        #                [signed_order_statement], signed_request)
        signed_request = order_proof[6]
        decoded_req = ast.literal_eval(signed_request.message.decode())
        if not verify(signed_request, decoded_req[1], type="client"):
            output('signature verification failed for request', decoded_req[0], level=logging.INFO)
            return False
        request = order_proof[2]
        # verify order proof for preceding replicas
        for ord_stmnt in order_proof[5]:
            # get replica id from order_statement
            decoded_message = ast.literal_eval(ord_stmnt.message.decode())
            rplca_id = decoded_message[3]
            request_from_order_statement = decoded_message[2]
            if not verify(ord_stmnt, rplca_id) or request_from_order_statement != request:
                output('order proof validation failed for replica', rplca_id, level=logging.CRITICAL)
                return False

        return True

    # check if proof of misbehaviour sent by client has some issue or not
    # if issue is not found in the proof of misbehaviour then reconfiguration request is not valid
    def result_sent_by_client_valid(proof):
        result = proof[0]
        result_proof = proof[1]
        if len(result_proof) != len(self.configuration):
            output('result proof verification failed due to insufficient'
                   ' number of result statements', level=logging.CRITICAL)
            return False
        result_hash = crypto_hash(result)
        count = 0
        for replica_result_proof in result_proof:
            decoded_message = ast.literal_eval(replica_result_proof.message.decode())
            rplca_id = decoded_message[3]
            if not verify(replica_result_proof, rplca_id) or decoded_message[4] != result_hash:
                if not verify(replica_result_proof, rplca_id):
                    output('signature validation failed for replica id', rplca_id, level=logging.CRITICAL)
                else:
                    output('result hash is different for', rplca_id, level=logging.CRITICAL)
            else:
                count += 1
        if count != (2 * self.t + 1):
            output('result proofs are not correct for all replicas or some are missing',
                   level=logging.CRITICAL)
            return False
        return count >= (self.t + 1)

    def is_checkpoint_proof_shuttle_valid(checkpt_proof):
        if checkpt_proof is None:
            return True
        if len(checkpt_proof) != len(self.configuration):
            output('checkpt shuttle verification failed due to insufficient number of checkpt statements',
                   level=logging.CRITICAL)
            return False

        state_hash = None
        for checkpt in checkpt_proof:
            decoded_message = ast.literal_eval(checkpt.message.decode())
            rplca_id = decoded_message[2]
            rplca_state_hash = decoded_message[1]
            state_hash = rplca_state_hash if state_hash is None else state_hash
            if not verify(checkpt, rplca_id) or rplca_state_hash != state_hash:
                output('checkpt shuttle verification failed for replica', rplca_id, level=logging.CRITICAL)
                return False

        return True

    def terminate_all_replicas():
        for replica in self.configuration:
            send(('done'), to=replica)
            send(('terminate'), to=replica)
        self.configuration = []
        self.all_replicas_public_keys = {}
        self.configuration = []  # current configuration
        self.replica_map = {}

    def create_configuration(state_obj=None):
        """ creating num_replica replicas """
        start_replicas(state_obj)
        send_client_public_keys_to_replicas()

    def run():
        self.crypto_keys = generate_keys()
        register_to_clients()
        create_configuration()
        # wait till all clients have finished execution
        await(self.num_clients_finished == len(self.clients))
        terminate_all_replicas()
        send(('done'), to=self.bcr_main)
        #await(received(('done')))

        output('olympus run finished!')

    def send_client_public_keys_to_replicas():
        output('sending all_clients_public_keys to replicas', level=logging.INFO)
        for replica in self.configuration:
            send(('all_clients_public_keys', self.all_clients_public_keys), to=replica)

    def register_to_clients():
        for cnt_id in clients:
            key_pair = generate_keys()
            self.all_clients_public_keys[cnt_id] = key_pair[1]
            send(('all_crypto_keys', self.crypto_keys[1],
                  key_pair, self.all_replicas_public_keys), to=clients[cnt_id])

    def start_replicas(state_obj):
        """start num_replicas replicas"""
        output("starting replicas...", level=logging.INFO)
        for itr in range(num_replica):
            key_pair = generate_keys()
            replica_id = 'replica' + str(itr)
            self.all_replicas_public_keys[replica_id] = key_pair[1]
            if itr == 0:
                timeout = self.head_timeout
            else:
                timeout = self.nonhead_timeout
            replica = new(replica_module.Replica, [replica_id, itr, key_pair,
                                                   clients, failure_scenarios.get(itr), timeout, checkpt_interval,
                                                   self.crypto_keys[1], state_obj], num=1)
            self.configuration.append(replica)
            self.replica_map[replica_id] = replica
            start(replica)

        """send public keys and config to replica"""
        for replica in self.configuration:
            send(('inithist', sign([])), to=replica)
            send(('all_replicas_public_keys', sign(self.all_replicas_public_keys)), to=replica)
            send(('config', self.configuration, self.configuration_number), to=replica)

            #send(('done',), to=replica)

        output("started all replicas", level=logging.INFO)


def main():
    olympus = new(Olympus, [1, 1])
    start(olympus)
